---
title: "OS ch8 메모리관리_2_swapping"
categories:
    - OS
tags:
    - OS,Memory management,swapping
---

# CH8-2 Swapping
모든 프로세스는 실행되기 위해서 메모리에 존재해야합니다. 하지만 임시적으로 메모리에서 디스크(backing store)에 저장되었다가 다시 메모리로 복귀할 수 있는데 이를 스와핑(Swappint)이라고 한다. 스와핑은 모든 프로세스의 메모리 필요량이 물리 메모리 총량을 넘어서게 하는 것을 가능하게해 시스템에서 멀티 프로그래밍 수준을 높여주는 역할을 한다.

## Standard Swapping
> * Standard swapping은 메인 메모리와 backing store(일반 적으로 fast disk, 모든 사용자의 메모리 이미지 복사본을 수용할 수 있을정도로 크고 직접 접근 가능해야함.) 사이에 프로세스의 이동을 포함하는 개념이다.

시스템은 디스크나 메모리에 로드되어 있으면서 실행 준비가 완료된 모든 프로세스를 관리하는 레디 큐(ready queue)를 가집니다. CPU 스케쥴러가 (스케쥴링 기법에 따라 언제든지 상관 없이) 실행할 프로세스를 결정하고 **dispatcher**를 호출합니다. dispatcher는 (큐에 존재하는) 실행할 프로세스가 메모리에 올라와있는지 확인합니다. 만약 메모리에 올라와있지 않고 메모리에 여유공간이 없는 경우 현재 실행중인 프로세스와 실행할 프로세스의 메모리 공간을 스왑합니다. 그리고 레지스터들을 리로드(reload)한 뒤 실행할 프로세스로 제어권을 넘겨줍니다.   
   
스와핑 시스템(Swapping system)에서 context-switch 소요 시간은 꽤 높습니다. 
예시로 사용자 프로세스 크기가 100MB이고 하드 디스크의 초당 전송량은 50MB라고 가정을 해보겠습니다. 100MB에 대한 실제 전송 시간은 2초가 걸릴 것 입니다(디스크의 퍼포먼스는 제외). 스와핑은 메모리 밖으로 내보내고 새로운 프로세스를 메모리에 로드하므로 (out an in) 각각 2초씩 총 4초의 시간이 소요됩니다.

스와핑 소요 시간 중 대부분은 전송 시간(위 문단 내용)입니다. 전체 전송 시간은 메모리의 스왑량에 비례합니다. 만약 총 메모리 크기가 4GB이고 커널 메모리가 1GB, 사용자가 가용 가능한 공간이 3GB라고 가정(실제 유저 프로세스는 대부분 100MB정도를 사용)을 해봅시다. 100MB를 전송하는데는 2초가 필요하고 3GB를 전송하는데는 60초가 필요합니다. 유저 프로세스가 **사용 할** 메모리 공간을 파악하는 것 보다 **사용 중**인 메모리 공간을 파악하는 것이 명료합니다. 그러므로 스왑 시간을 줄이기 위해서는 현재 사용중인 메모리만 스왑하는 것이 필요합니다. 이 방법을 효과적으로 사용하려면 사용자는 시스템에게 메모리 요구사항의 변경 점을 알려야합니다. 따라서 동적 메모리를 요구하는 프로세스는 운영체제에 메모리 변경 사항을 알려주는 시스템 콜(request_memory(), release_memory())을 호출해야합니다.

또 다른 스와핑의 제약사항은 프로세스를 스왑할 때 프로세스가 완전히 idle상태인지 확인해야합니다. 특히 I/O작업 중인 상황을 조심해야하는데, I/O작업은 비동기적으로 사용자 메모리(I/O Buffer)에 접근중이므로 스왑을 할 수 없습니다. 이유는 p1프로세스가 실행중이고 새로운 프로세스를 p2라 가정했을 때 스왑이 완료된 다음 I/O작업이 완료된다면 사용자가 의도한 p1에 I/O작업 결과가 저장되는 것이 아니라 p2에 작업결과가 저장되는 문제가 발생한다.   
위와 같은 문제를 막기 위한 방법엔 2가지가 있습니다.   
1. I/O 대기중인 프로세스 스왑을 하지 않는다.
2. I/O 작업을 운영체제의 버퍼와만 수행한다.   

2번을 조금 더 살펴보면 프로세스가 swap in 상태에서만 가능하며, **double buffering**(사용자가 I/O 결과에 엑세스 하기 위해서는 커널영역에 존재하는 운영체제 버퍼에서 유저 영역 메모리로 데이터를 한번 더 복사하는 과정)은 오버헤드를 발생시킨다.

Standard swapping은 현대 운영체제에서는 사용하지 않는 방법이다. 스와핑 시간 많이 소요돼서 실행시간이 적어지기 때문에 합리적인 메모리 관리 기법이 아니기 때문이다.

대신에 Standard swapping을 수정한 버전을 많은 시스템들(UNIX, LINUX, WINDOWS)에서 사용한다. 수정된 버전에서는 기본적으로 스와핑을 하지 않다가 메모리 사용량의 한계(운영체제나 유저 프로세스가 사용할 메모리 공간이 적어지는 상황)이 오면 스와핑을 합니다. 그리고 사용 가능한 메모리 공간이 커지면 다시 스와핑을 중단하며 전체 프로세스를 스왑하는 것이 아니라 프로세스의 일부를 스와핑 합니다.   
*가상메모리를 활용한 수정된 스와핑 기법은 ch9에서 다룹니다.*

## Swapping on Mobile Systems
> * 일반적으로 모바일 시스템에서는 스와핑을 지원하지 않습니다.
> * 모바일 장치는 영구 저장장치로 하드 디스크가 아니라 플래시 메모리를 사용합니다.

모바일 시스템에서 스와핑을 피한 이유는 아래와 같다.
1. 크기가 큰 하드 디스크가 아닌 플래시 메모리를 사용하기 때문에 공간 제약문제가 발생한다.
2. 메인 메모리와 플래시 메모리 간 처리량이 낮아지거나 데이터를 신뢰할 수 없게되기 전에 쓰기 작업량을 제한하기 때문이다.   

애플의 경우 스와핑 대신에 여유 메모리 크기가 특정 한계치 밑으로 떨어질때 어플리케이션에 할당된 메모리를 자발적으로 포기하게끔 요청한다. 코드 같은 읽기 전용 데이터는 시스템에서 제거한 뒤 나중에 필요할 때 재로드(reload)한다. 스택 같이 수정되는 데이터는 제거되지 않는다. 그러나 충분한 메모리를 확보하지 못한 어플리케이션은 운영체제가 강제 종료(terminated)한다.   
안드로이드는 애플의 IOS와 같은 전략을 채택했지만 프로세스를 종료하기 전에 어플리케이션 상태(application state)를 플래시 메모리에 저장해서 빠른 재시작이 가능하게 한 것이 차이점이다.

위와 같은 제한 때문에 모바일 시스템 개발자들은 꼭 메모리 할당과 해제를 신중하게 해야하고 어플리케이션이 많은 메모리를 사용하거나 메모리 릭을 악화시키지 않도록 해야한다. IOS와 안드로이드는 메모리 관리 능력을 위해 페이징(paging)기법을 사용한다.


[log]
- 2020/09/04 : 표준 스와핑
- 2020/09/05 : 모바일 시스템에서의 스와핑